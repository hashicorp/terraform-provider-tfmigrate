// Code generated by mockery v2.51.1. DO NOT EDIT.

package git_mocks

import (
	constants "terraform-provider-tfmigrate/internal/constants"

	config "github.com/go-git/go-git/v5/config"

	git "github.com/go-git/go-git/v5"

	gitlab "gitlab.com/gitlab-org/api/client-go"

	mock "github.com/stretchr/testify/mock"

	object "github.com/go-git/go-git/v5/plumbing/object"

	plumbing "github.com/go-git/go-git/v5/plumbing"

	storer "github.com/go-git/go-git/v5/plumbing/storer"

	vcsgit "terraform-provider-tfmigrate/internal/util/vcs/git"
)

// MockGitUtil is an autogenerated mock type for the GitUtil type
type MockGitUtil struct {
	mock.Mock
}

type MockGitUtil_Expecter struct {
	mock *mock.Mock
}

func (_m *MockGitUtil) EXPECT() *MockGitUtil_Expecter {
	return &MockGitUtil_Expecter{mock: &_m.Mock}
}

// Add provides a mock function with given fields: worktree, glob
func (_m *MockGitUtil) Add(worktree *git.Worktree, glob string) (plumbing.Hash, error) {
	ret := _m.Called(worktree, glob)

	if len(ret) == 0 {
		panic("no return value specified for Add")
	}

	var r0 plumbing.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(*git.Worktree, string) (plumbing.Hash, error)); ok {
		return rf(worktree, glob)
	}
	if rf, ok := ret.Get(0).(func(*git.Worktree, string) plumbing.Hash); ok {
		r0 = rf(worktree, glob)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(plumbing.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(*git.Worktree, string) error); ok {
		r1 = rf(worktree, glob)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitUtil_Add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Add'
type MockGitUtil_Add_Call struct {
	*mock.Call
}

// Add is a helper method to define mock.On call
//   - worktree *git.Worktree
//   - glob string
func (_e *MockGitUtil_Expecter) Add(worktree interface{}, glob interface{}) *MockGitUtil_Add_Call {
	return &MockGitUtil_Add_Call{Call: _e.mock.On("Add", worktree, glob)}
}

func (_c *MockGitUtil_Add_Call) Run(run func(worktree *git.Worktree, glob string)) *MockGitUtil_Add_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*git.Worktree), args[1].(string))
	})
	return _c
}

func (_c *MockGitUtil_Add_Call) Return(_a0 plumbing.Hash, _a1 error) *MockGitUtil_Add_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitUtil_Add_Call) RunAndReturn(run func(*git.Worktree, string) (plumbing.Hash, error)) *MockGitUtil_Add_Call {
	_c.Call.Return(run)
	return _c
}

// Branches provides a mock function with given fields: repo
func (_m *MockGitUtil) Branches(repo *git.Repository) (storer.ReferenceIter, error) {
	ret := _m.Called(repo)

	if len(ret) == 0 {
		panic("no return value specified for Branches")
	}

	var r0 storer.ReferenceIter
	var r1 error
	if rf, ok := ret.Get(0).(func(*git.Repository) (storer.ReferenceIter, error)); ok {
		return rf(repo)
	}
	if rf, ok := ret.Get(0).(func(*git.Repository) storer.ReferenceIter); ok {
		r0 = rf(repo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(storer.ReferenceIter)
		}
	}

	if rf, ok := ret.Get(1).(func(*git.Repository) error); ok {
		r1 = rf(repo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitUtil_Branches_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Branches'
type MockGitUtil_Branches_Call struct {
	*mock.Call
}

// Branches is a helper method to define mock.On call
//   - repo *git.Repository
func (_e *MockGitUtil_Expecter) Branches(repo interface{}) *MockGitUtil_Branches_Call {
	return &MockGitUtil_Branches_Call{Call: _e.mock.On("Branches", repo)}
}

func (_c *MockGitUtil_Branches_Call) Run(run func(repo *git.Repository)) *MockGitUtil_Branches_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*git.Repository))
	})
	return _c
}

func (_c *MockGitUtil_Branches_Call) Return(_a0 storer.ReferenceIter, _a1 error) *MockGitUtil_Branches_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitUtil_Branches_Call) RunAndReturn(run func(*git.Repository) (storer.ReferenceIter, error)) *MockGitUtil_Branches_Call {
	_c.Call.Return(run)
	return _c
}

// Checkout provides a mock function with given fields: w, options
func (_m *MockGitUtil) Checkout(w *git.Worktree, options *git.CheckoutOptions) error {
	ret := _m.Called(w, options)

	if len(ret) == 0 {
		panic("no return value specified for Checkout")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*git.Worktree, *git.CheckoutOptions) error); ok {
		r0 = rf(w, options)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGitUtil_Checkout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Checkout'
type MockGitUtil_Checkout_Call struct {
	*mock.Call
}

// Checkout is a helper method to define mock.On call
//   - w *git.Worktree
//   - options *git.CheckoutOptions
func (_e *MockGitUtil_Expecter) Checkout(w interface{}, options interface{}) *MockGitUtil_Checkout_Call {
	return &MockGitUtil_Checkout_Call{Call: _e.mock.On("Checkout", w, options)}
}

func (_c *MockGitUtil_Checkout_Call) Run(run func(w *git.Worktree, options *git.CheckoutOptions)) *MockGitUtil_Checkout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*git.Worktree), args[1].(*git.CheckoutOptions))
	})
	return _c
}

func (_c *MockGitUtil_Checkout_Call) Return(_a0 error) *MockGitUtil_Checkout_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGitUtil_Checkout_Call) RunAndReturn(run func(*git.Worktree, *git.CheckoutOptions) error) *MockGitUtil_Checkout_Call {
	_c.Call.Return(run)
	return _c
}

// Commit provides a mock function with given fields: worktree, msg, options
func (_m *MockGitUtil) Commit(worktree *git.Worktree, msg string, options *git.CommitOptions) (plumbing.Hash, error) {
	ret := _m.Called(worktree, msg, options)

	if len(ret) == 0 {
		panic("no return value specified for Commit")
	}

	var r0 plumbing.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(*git.Worktree, string, *git.CommitOptions) (plumbing.Hash, error)); ok {
		return rf(worktree, msg, options)
	}
	if rf, ok := ret.Get(0).(func(*git.Worktree, string, *git.CommitOptions) plumbing.Hash); ok {
		r0 = rf(worktree, msg, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(plumbing.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(*git.Worktree, string, *git.CommitOptions) error); ok {
		r1 = rf(worktree, msg, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitUtil_Commit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Commit'
type MockGitUtil_Commit_Call struct {
	*mock.Call
}

// Commit is a helper method to define mock.On call
//   - worktree *git.Worktree
//   - msg string
//   - options *git.CommitOptions
func (_e *MockGitUtil_Expecter) Commit(worktree interface{}, msg interface{}, options interface{}) *MockGitUtil_Commit_Call {
	return &MockGitUtil_Commit_Call{Call: _e.mock.On("Commit", worktree, msg, options)}
}

func (_c *MockGitUtil_Commit_Call) Run(run func(worktree *git.Worktree, msg string, options *git.CommitOptions)) *MockGitUtil_Commit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*git.Worktree), args[1].(string), args[2].(*git.CommitOptions))
	})
	return _c
}

func (_c *MockGitUtil_Commit_Call) Return(_a0 plumbing.Hash, _a1 error) *MockGitUtil_Commit_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitUtil_Commit_Call) RunAndReturn(run func(*git.Worktree, string, *git.CommitOptions) (plumbing.Hash, error)) *MockGitUtil_Commit_Call {
	_c.Call.Return(run)
	return _c
}

// CommitObject provides a mock function with given fields: repo, hash
func (_m *MockGitUtil) CommitObject(repo *git.Repository, hash plumbing.Hash) (*object.Commit, error) {
	ret := _m.Called(repo, hash)

	if len(ret) == 0 {
		panic("no return value specified for CommitObject")
	}

	var r0 *object.Commit
	var r1 error
	if rf, ok := ret.Get(0).(func(*git.Repository, plumbing.Hash) (*object.Commit, error)); ok {
		return rf(repo, hash)
	}
	if rf, ok := ret.Get(0).(func(*git.Repository, plumbing.Hash) *object.Commit); ok {
		r0 = rf(repo, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*object.Commit)
		}
	}

	if rf, ok := ret.Get(1).(func(*git.Repository, plumbing.Hash) error); ok {
		r1 = rf(repo, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitUtil_CommitObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CommitObject'
type MockGitUtil_CommitObject_Call struct {
	*mock.Call
}

// CommitObject is a helper method to define mock.On call
//   - repo *git.Repository
//   - hash plumbing.Hash
func (_e *MockGitUtil_Expecter) CommitObject(repo interface{}, hash interface{}) *MockGitUtil_CommitObject_Call {
	return &MockGitUtil_CommitObject_Call{Call: _e.mock.On("CommitObject", repo, hash)}
}

func (_c *MockGitUtil_CommitObject_Call) Run(run func(repo *git.Repository, hash plumbing.Hash)) *MockGitUtil_CommitObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*git.Repository), args[1].(plumbing.Hash))
	})
	return _c
}

func (_c *MockGitUtil_CommitObject_Call) Return(_a0 *object.Commit, _a1 error) *MockGitUtil_CommitObject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitUtil_CommitObject_Call) RunAndReturn(run func(*git.Repository, plumbing.Hash) (*object.Commit, error)) *MockGitUtil_CommitObject_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigScoped provides a mock function with given fields: repo, scope
func (_m *MockGitUtil) ConfigScoped(repo *git.Repository, scope config.Scope) (*config.Config, error) {
	ret := _m.Called(repo, scope)

	if len(ret) == 0 {
		panic("no return value specified for ConfigScoped")
	}

	var r0 *config.Config
	var r1 error
	if rf, ok := ret.Get(0).(func(*git.Repository, config.Scope) (*config.Config, error)); ok {
		return rf(repo, scope)
	}
	if rf, ok := ret.Get(0).(func(*git.Repository, config.Scope) *config.Config); ok {
		r0 = rf(repo, scope)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*config.Config)
		}
	}

	if rf, ok := ret.Get(1).(func(*git.Repository, config.Scope) error); ok {
		r1 = rf(repo, scope)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitUtil_ConfigScoped_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigScoped'
type MockGitUtil_ConfigScoped_Call struct {
	*mock.Call
}

// ConfigScoped is a helper method to define mock.On call
//   - repo *git.Repository
//   - scope config.Scope
func (_e *MockGitUtil_Expecter) ConfigScoped(repo interface{}, scope interface{}) *MockGitUtil_ConfigScoped_Call {
	return &MockGitUtil_ConfigScoped_Call{Call: _e.mock.On("ConfigScoped", repo, scope)}
}

func (_c *MockGitUtil_ConfigScoped_Call) Run(run func(repo *git.Repository, scope config.Scope)) *MockGitUtil_ConfigScoped_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*git.Repository), args[1].(config.Scope))
	})
	return _c
}

func (_c *MockGitUtil_ConfigScoped_Call) Return(_a0 *config.Config, _a1 error) *MockGitUtil_ConfigScoped_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitUtil_ConfigScoped_Call) RunAndReturn(run func(*git.Repository, config.Scope) (*config.Config, error)) *MockGitUtil_ConfigScoped_Call {
	_c.Call.Return(run)
	return _c
}

// GetGitToken provides a mock function with given fields: gitServiceProvider, tokenFromProvider
func (_m *MockGitUtil) GetGitToken(gitServiceProvider *constants.GitServiceProvider, tokenFromProvider string) (string, error) {
	ret := _m.Called(gitServiceProvider, tokenFromProvider)

	if len(ret) == 0 {
		panic("no return value specified for GetGitToken")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(*constants.GitServiceProvider, string) (string, error)); ok {
		return rf(gitServiceProvider, tokenFromProvider)
	}
	if rf, ok := ret.Get(0).(func(*constants.GitServiceProvider, string) string); ok {
		r0 = rf(gitServiceProvider, tokenFromProvider)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(*constants.GitServiceProvider, string) error); ok {
		r1 = rf(gitServiceProvider, tokenFromProvider)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitUtil_GetGitToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGitToken'
type MockGitUtil_GetGitToken_Call struct {
	*mock.Call
}

// GetGitToken is a helper method to define mock.On call
//   - gitServiceProvider *constants.GitServiceProvider
//   - tokenFromProvider string
func (_e *MockGitUtil_Expecter) GetGitToken(gitServiceProvider interface{}, tokenFromProvider interface{}) *MockGitUtil_GetGitToken_Call {
	return &MockGitUtil_GetGitToken_Call{Call: _e.mock.On("GetGitToken", gitServiceProvider, tokenFromProvider)}
}

func (_c *MockGitUtil_GetGitToken_Call) Run(run func(gitServiceProvider *constants.GitServiceProvider, tokenFromProvider string)) *MockGitUtil_GetGitToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*constants.GitServiceProvider), args[1].(string))
	})
	return _c
}

func (_c *MockGitUtil_GetGitToken_Call) Return(_a0 string, _a1 error) *MockGitUtil_GetGitToken_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitUtil_GetGitToken_Call) RunAndReturn(run func(*constants.GitServiceProvider, string) (string, error)) *MockGitUtil_GetGitToken_Call {
	_c.Call.Return(run)
	return _c
}

// GetOrgAndRepoName provides a mock function with given fields: repoIdentifier
func (_m *MockGitUtil) GetOrgAndRepoName(repoIdentifier string) (string, string) {
	ret := _m.Called(repoIdentifier)

	if len(ret) == 0 {
		panic("no return value specified for GetOrgAndRepoName")
	}

	var r0 string
	var r1 string
	if rf, ok := ret.Get(0).(func(string) (string, string)); ok {
		return rf(repoIdentifier)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(repoIdentifier)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) string); ok {
		r1 = rf(repoIdentifier)
	} else {
		r1 = ret.Get(1).(string)
	}

	return r0, r1
}

// MockGitUtil_GetOrgAndRepoName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOrgAndRepoName'
type MockGitUtil_GetOrgAndRepoName_Call struct {
	*mock.Call
}

// GetOrgAndRepoName is a helper method to define mock.On call
//   - repoIdentifier string
func (_e *MockGitUtil_Expecter) GetOrgAndRepoName(repoIdentifier interface{}) *MockGitUtil_GetOrgAndRepoName_Call {
	return &MockGitUtil_GetOrgAndRepoName_Call{Call: _e.mock.On("GetOrgAndRepoName", repoIdentifier)}
}

func (_c *MockGitUtil_GetOrgAndRepoName_Call) Run(run func(repoIdentifier string)) *MockGitUtil_GetOrgAndRepoName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockGitUtil_GetOrgAndRepoName_Call) Return(_a0 string, _a1 string) *MockGitUtil_GetOrgAndRepoName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitUtil_GetOrgAndRepoName_Call) RunAndReturn(run func(string) (string, string)) *MockGitUtil_GetOrgAndRepoName_Call {
	_c.Call.Return(run)
	return _c
}

// GetRemoteServiceProvider provides a mock function with given fields: remoteURL
func (_m *MockGitUtil) GetRemoteServiceProvider(remoteURL string) *constants.GitServiceProvider {
	ret := _m.Called(remoteURL)

	if len(ret) == 0 {
		panic("no return value specified for GetRemoteServiceProvider")
	}

	var r0 *constants.GitServiceProvider
	if rf, ok := ret.Get(0).(func(string) *constants.GitServiceProvider); ok {
		r0 = rf(remoteURL)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*constants.GitServiceProvider)
		}
	}

	return r0
}

// MockGitUtil_GetRemoteServiceProvider_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRemoteServiceProvider'
type MockGitUtil_GetRemoteServiceProvider_Call struct {
	*mock.Call
}

// GetRemoteServiceProvider is a helper method to define mock.On call
//   - remoteURL string
func (_e *MockGitUtil_Expecter) GetRemoteServiceProvider(remoteURL interface{}) *MockGitUtil_GetRemoteServiceProvider_Call {
	return &MockGitUtil_GetRemoteServiceProvider_Call{Call: _e.mock.On("GetRemoteServiceProvider", remoteURL)}
}

func (_c *MockGitUtil_GetRemoteServiceProvider_Call) Run(run func(remoteURL string)) *MockGitUtil_GetRemoteServiceProvider_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockGitUtil_GetRemoteServiceProvider_Call) Return(_a0 *constants.GitServiceProvider) *MockGitUtil_GetRemoteServiceProvider_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGitUtil_GetRemoteServiceProvider_Call) RunAndReturn(run func(string) *constants.GitServiceProvider) *MockGitUtil_GetRemoteServiceProvider_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepoIdentifier provides a mock function with given fields: remoteURL
func (_m *MockGitUtil) GetRepoIdentifier(remoteURL string) string {
	ret := _m.Called(remoteURL)

	if len(ret) == 0 {
		panic("no return value specified for GetRepoIdentifier")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(remoteURL)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// MockGitUtil_GetRepoIdentifier_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepoIdentifier'
type MockGitUtil_GetRepoIdentifier_Call struct {
	*mock.Call
}

// GetRepoIdentifier is a helper method to define mock.On call
//   - remoteURL string
func (_e *MockGitUtil_Expecter) GetRepoIdentifier(remoteURL interface{}) *MockGitUtil_GetRepoIdentifier_Call {
	return &MockGitUtil_GetRepoIdentifier_Call{Call: _e.mock.On("GetRepoIdentifier", remoteURL)}
}

func (_c *MockGitUtil_GetRepoIdentifier_Call) Run(run func(remoteURL string)) *MockGitUtil_GetRepoIdentifier_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockGitUtil_GetRepoIdentifier_Call) Return(_a0 string) *MockGitUtil_GetRepoIdentifier_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGitUtil_GetRepoIdentifier_Call) RunAndReturn(run func(string) string) *MockGitUtil_GetRepoIdentifier_Call {
	_c.Call.Return(run)
	return _c
}

// GlobalGitConfig provides a mock function with no fields
func (_m *MockGitUtil) GlobalGitConfig() (vcsgit.GitUserConfig, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GlobalGitConfig")
	}

	var r0 vcsgit.GitUserConfig
	var r1 error
	if rf, ok := ret.Get(0).(func() (vcsgit.GitUserConfig, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() vcsgit.GitUserConfig); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(vcsgit.GitUserConfig)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitUtil_GlobalGitConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GlobalGitConfig'
type MockGitUtil_GlobalGitConfig_Call struct {
	*mock.Call
}

// GlobalGitConfig is a helper method to define mock.On call
func (_e *MockGitUtil_Expecter) GlobalGitConfig() *MockGitUtil_GlobalGitConfig_Call {
	return &MockGitUtil_GlobalGitConfig_Call{Call: _e.mock.On("GlobalGitConfig")}
}

func (_c *MockGitUtil_GlobalGitConfig_Call) Run(run func()) *MockGitUtil_GlobalGitConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGitUtil_GlobalGitConfig_Call) Return(_a0 vcsgit.GitUserConfig, _a1 error) *MockGitUtil_GlobalGitConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitUtil_GlobalGitConfig_Call) RunAndReturn(run func() (vcsgit.GitUserConfig, error)) *MockGitUtil_GlobalGitConfig_Call {
	_c.Call.Return(run)
	return _c
}

// Head provides a mock function with given fields: repo
func (_m *MockGitUtil) Head(repo *git.Repository) (*plumbing.Reference, error) {
	ret := _m.Called(repo)

	if len(ret) == 0 {
		panic("no return value specified for Head")
	}

	var r0 *plumbing.Reference
	var r1 error
	if rf, ok := ret.Get(0).(func(*git.Repository) (*plumbing.Reference, error)); ok {
		return rf(repo)
	}
	if rf, ok := ret.Get(0).(func(*git.Repository) *plumbing.Reference); ok {
		r0 = rf(repo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*plumbing.Reference)
		}
	}

	if rf, ok := ret.Get(1).(func(*git.Repository) error); ok {
		r1 = rf(repo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitUtil_Head_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Head'
type MockGitUtil_Head_Call struct {
	*mock.Call
}

// Head is a helper method to define mock.On call
//   - repo *git.Repository
func (_e *MockGitUtil_Expecter) Head(repo interface{}) *MockGitUtil_Head_Call {
	return &MockGitUtil_Head_Call{Call: _e.mock.On("Head", repo)}
}

func (_c *MockGitUtil_Head_Call) Run(run func(repo *git.Repository)) *MockGitUtil_Head_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*git.Repository))
	})
	return _c
}

func (_c *MockGitUtil_Head_Call) Return(_a0 *plumbing.Reference, _a1 error) *MockGitUtil_Head_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitUtil_Head_Call) RunAndReturn(run func(*git.Repository) (*plumbing.Reference, error)) *MockGitUtil_Head_Call {
	_c.Call.Return(run)
	return _c
}

// NewGitLabClient provides a mock function with given fields: gitlabToken
func (_m *MockGitUtil) NewGitLabClient(gitlabToken string) (*gitlab.Client, error) {
	ret := _m.Called(gitlabToken)

	if len(ret) == 0 {
		panic("no return value specified for NewGitLabClient")
	}

	var r0 *gitlab.Client
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*gitlab.Client, error)); ok {
		return rf(gitlabToken)
	}
	if rf, ok := ret.Get(0).(func(string) *gitlab.Client); ok {
		r0 = rf(gitlabToken)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Client)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(gitlabToken)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitUtil_NewGitLabClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewGitLabClient'
type MockGitUtil_NewGitLabClient_Call struct {
	*mock.Call
}

// NewGitLabClient is a helper method to define mock.On call
//   - gitlabToken string
func (_e *MockGitUtil_Expecter) NewGitLabClient(gitlabToken interface{}) *MockGitUtil_NewGitLabClient_Call {
	return &MockGitUtil_NewGitLabClient_Call{Call: _e.mock.On("NewGitLabClient", gitlabToken)}
}

func (_c *MockGitUtil_NewGitLabClient_Call) Run(run func(gitlabToken string)) *MockGitUtil_NewGitLabClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockGitUtil_NewGitLabClient_Call) Return(_a0 *gitlab.Client, _a1 error) *MockGitUtil_NewGitLabClient_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitUtil_NewGitLabClient_Call) RunAndReturn(run func(string) (*gitlab.Client, error)) *MockGitUtil_NewGitLabClient_Call {
	_c.Call.Return(run)
	return _c
}

// OpenRepository provides a mock function with given fields: repoPath
func (_m *MockGitUtil) OpenRepository(repoPath string) (*git.Repository, error) {
	ret := _m.Called(repoPath)

	if len(ret) == 0 {
		panic("no return value specified for OpenRepository")
	}

	var r0 *git.Repository
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*git.Repository, error)); ok {
		return rf(repoPath)
	}
	if rf, ok := ret.Get(0).(func(string) *git.Repository); ok {
		r0 = rf(repoPath)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*git.Repository)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(repoPath)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitUtil_OpenRepository_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OpenRepository'
type MockGitUtil_OpenRepository_Call struct {
	*mock.Call
}

// OpenRepository is a helper method to define mock.On call
//   - repoPath string
func (_e *MockGitUtil_Expecter) OpenRepository(repoPath interface{}) *MockGitUtil_OpenRepository_Call {
	return &MockGitUtil_OpenRepository_Call{Call: _e.mock.On("OpenRepository", repoPath)}
}

func (_c *MockGitUtil_OpenRepository_Call) Run(run func(repoPath string)) *MockGitUtil_OpenRepository_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockGitUtil_OpenRepository_Call) Return(_a0 *git.Repository, _a1 error) *MockGitUtil_OpenRepository_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitUtil_OpenRepository_Call) RunAndReturn(run func(string) (*git.Repository, error)) *MockGitUtil_OpenRepository_Call {
	_c.Call.Return(run)
	return _c
}

// PlainOpenWithOptions provides a mock function with given fields: path, options
func (_m *MockGitUtil) PlainOpenWithOptions(path string, options *git.PlainOpenOptions) (*git.Repository, error) {
	ret := _m.Called(path, options)

	if len(ret) == 0 {
		panic("no return value specified for PlainOpenWithOptions")
	}

	var r0 *git.Repository
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *git.PlainOpenOptions) (*git.Repository, error)); ok {
		return rf(path, options)
	}
	if rf, ok := ret.Get(0).(func(string, *git.PlainOpenOptions) *git.Repository); ok {
		r0 = rf(path, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*git.Repository)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *git.PlainOpenOptions) error); ok {
		r1 = rf(path, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitUtil_PlainOpenWithOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PlainOpenWithOptions'
type MockGitUtil_PlainOpenWithOptions_Call struct {
	*mock.Call
}

// PlainOpenWithOptions is a helper method to define mock.On call
//   - path string
//   - options *git.PlainOpenOptions
func (_e *MockGitUtil_Expecter) PlainOpenWithOptions(path interface{}, options interface{}) *MockGitUtil_PlainOpenWithOptions_Call {
	return &MockGitUtil_PlainOpenWithOptions_Call{Call: _e.mock.On("PlainOpenWithOptions", path, options)}
}

func (_c *MockGitUtil_PlainOpenWithOptions_Call) Run(run func(path string, options *git.PlainOpenOptions)) *MockGitUtil_PlainOpenWithOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*git.PlainOpenOptions))
	})
	return _c
}

func (_c *MockGitUtil_PlainOpenWithOptions_Call) Return(_a0 *git.Repository, _a1 error) *MockGitUtil_PlainOpenWithOptions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitUtil_PlainOpenWithOptions_Call) RunAndReturn(run func(string, *git.PlainOpenOptions) (*git.Repository, error)) *MockGitUtil_PlainOpenWithOptions_Call {
	_c.Call.Return(run)
	return _c
}

// Push provides a mock function with given fields: repo, options
func (_m *MockGitUtil) Push(repo *git.Repository, options *git.PushOptions) error {
	ret := _m.Called(repo, options)

	if len(ret) == 0 {
		panic("no return value specified for Push")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*git.Repository, *git.PushOptions) error); ok {
		r0 = rf(repo, options)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGitUtil_Push_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Push'
type MockGitUtil_Push_Call struct {
	*mock.Call
}

// Push is a helper method to define mock.On call
//   - repo *git.Repository
//   - options *git.PushOptions
func (_e *MockGitUtil_Expecter) Push(repo interface{}, options interface{}) *MockGitUtil_Push_Call {
	return &MockGitUtil_Push_Call{Call: _e.mock.On("Push", repo, options)}
}

func (_c *MockGitUtil_Push_Call) Run(run func(repo *git.Repository, options *git.PushOptions)) *MockGitUtil_Push_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*git.Repository), args[1].(*git.PushOptions))
	})
	return _c
}

func (_c *MockGitUtil_Push_Call) Return(_a0 error) *MockGitUtil_Push_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGitUtil_Push_Call) RunAndReturn(run func(*git.Repository, *git.PushOptions) error) *MockGitUtil_Push_Call {
	_c.Call.Return(run)
	return _c
}

// Remotes provides a mock function with given fields: repo
func (_m *MockGitUtil) Remotes(repo *git.Repository) ([]*git.Remote, error) {
	ret := _m.Called(repo)

	if len(ret) == 0 {
		panic("no return value specified for Remotes")
	}

	var r0 []*git.Remote
	var r1 error
	if rf, ok := ret.Get(0).(func(*git.Repository) ([]*git.Remote, error)); ok {
		return rf(repo)
	}
	if rf, ok := ret.Get(0).(func(*git.Repository) []*git.Remote); ok {
		r0 = rf(repo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*git.Remote)
		}
	}

	if rf, ok := ret.Get(1).(func(*git.Repository) error); ok {
		r1 = rf(repo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitUtil_Remotes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remotes'
type MockGitUtil_Remotes_Call struct {
	*mock.Call
}

// Remotes is a helper method to define mock.On call
//   - repo *git.Repository
func (_e *MockGitUtil_Expecter) Remotes(repo interface{}) *MockGitUtil_Remotes_Call {
	return &MockGitUtil_Remotes_Call{Call: _e.mock.On("Remotes", repo)}
}

func (_c *MockGitUtil_Remotes_Call) Run(run func(repo *git.Repository)) *MockGitUtil_Remotes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*git.Repository))
	})
	return _c
}

func (_c *MockGitUtil_Remotes_Call) Return(_a0 []*git.Remote, _a1 error) *MockGitUtil_Remotes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitUtil_Remotes_Call) RunAndReturn(run func(*git.Repository) ([]*git.Remote, error)) *MockGitUtil_Remotes_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveReference provides a mock function with given fields: _a0, _a1
func (_m *MockGitUtil) RemoveReference(_a0 storer.ReferenceStorer, _a1 plumbing.ReferenceName) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for RemoveReference")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(storer.ReferenceStorer, plumbing.ReferenceName) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGitUtil_RemoveReference_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveReference'
type MockGitUtil_RemoveReference_Call struct {
	*mock.Call
}

// RemoveReference is a helper method to define mock.On call
//   - _a0 storer.ReferenceStorer
//   - _a1 plumbing.ReferenceName
func (_e *MockGitUtil_Expecter) RemoveReference(_a0 interface{}, _a1 interface{}) *MockGitUtil_RemoveReference_Call {
	return &MockGitUtil_RemoveReference_Call{Call: _e.mock.On("RemoveReference", _a0, _a1)}
}

func (_c *MockGitUtil_RemoveReference_Call) Run(run func(_a0 storer.ReferenceStorer, _a1 plumbing.ReferenceName)) *MockGitUtil_RemoveReference_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(storer.ReferenceStorer), args[1].(plumbing.ReferenceName))
	})
	return _c
}

func (_c *MockGitUtil_RemoveReference_Call) Return(_a0 error) *MockGitUtil_RemoveReference_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGitUtil_RemoveReference_Call) RunAndReturn(run func(storer.ReferenceStorer, plumbing.ReferenceName) error) *MockGitUtil_RemoveReference_Call {
	_c.Call.Return(run)
	return _c
}

// Reset provides a mock function with given fields: worktree, options
func (_m *MockGitUtil) Reset(worktree *git.Worktree, options *git.ResetOptions) error {
	ret := _m.Called(worktree, options)

	if len(ret) == 0 {
		panic("no return value specified for Reset")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*git.Worktree, *git.ResetOptions) error); ok {
		r0 = rf(worktree, options)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGitUtil_Reset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Reset'
type MockGitUtil_Reset_Call struct {
	*mock.Call
}

// Reset is a helper method to define mock.On call
//   - worktree *git.Worktree
//   - options *git.ResetOptions
func (_e *MockGitUtil_Expecter) Reset(worktree interface{}, options interface{}) *MockGitUtil_Reset_Call {
	return &MockGitUtil_Reset_Call{Call: _e.mock.On("Reset", worktree, options)}
}

func (_c *MockGitUtil_Reset_Call) Run(run func(worktree *git.Worktree, options *git.ResetOptions)) *MockGitUtil_Reset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*git.Worktree), args[1].(*git.ResetOptions))
	})
	return _c
}

func (_c *MockGitUtil_Reset_Call) Return(_a0 error) *MockGitUtil_Reset_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGitUtil_Reset_Call) RunAndReturn(run func(*git.Worktree, *git.ResetOptions) error) *MockGitUtil_Reset_Call {
	_c.Call.Return(run)
	return _c
}

// Status provides a mock function with given fields: worktree
func (_m *MockGitUtil) Status(worktree *git.Worktree) (git.Status, error) {
	ret := _m.Called(worktree)

	if len(ret) == 0 {
		panic("no return value specified for Status")
	}

	var r0 git.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(*git.Worktree) (git.Status, error)); ok {
		return rf(worktree)
	}
	if rf, ok := ret.Get(0).(func(*git.Worktree) git.Status); ok {
		r0 = rf(worktree)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(git.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(*git.Worktree) error); ok {
		r1 = rf(worktree)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitUtil_Status_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Status'
type MockGitUtil_Status_Call struct {
	*mock.Call
}

// Status is a helper method to define mock.On call
//   - worktree *git.Worktree
func (_e *MockGitUtil_Expecter) Status(worktree interface{}) *MockGitUtil_Status_Call {
	return &MockGitUtil_Status_Call{Call: _e.mock.On("Status", worktree)}
}

func (_c *MockGitUtil_Status_Call) Run(run func(worktree *git.Worktree)) *MockGitUtil_Status_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*git.Worktree))
	})
	return _c
}

func (_c *MockGitUtil_Status_Call) Return(_a0 git.Status, _a1 error) *MockGitUtil_Status_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitUtil_Status_Call) RunAndReturn(run func(*git.Worktree) (git.Status, error)) *MockGitUtil_Status_Call {
	_c.Call.Return(run)
	return _c
}

// Worktree provides a mock function with given fields: repo
func (_m *MockGitUtil) Worktree(repo *git.Repository) (*git.Worktree, error) {
	ret := _m.Called(repo)

	if len(ret) == 0 {
		panic("no return value specified for Worktree")
	}

	var r0 *git.Worktree
	var r1 error
	if rf, ok := ret.Get(0).(func(*git.Repository) (*git.Worktree, error)); ok {
		return rf(repo)
	}
	if rf, ok := ret.Get(0).(func(*git.Repository) *git.Worktree); ok {
		r0 = rf(repo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*git.Worktree)
		}
	}

	if rf, ok := ret.Get(1).(func(*git.Repository) error); ok {
		r1 = rf(repo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGitUtil_Worktree_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Worktree'
type MockGitUtil_Worktree_Call struct {
	*mock.Call
}

// Worktree is a helper method to define mock.On call
//   - repo *git.Repository
func (_e *MockGitUtil_Expecter) Worktree(repo interface{}) *MockGitUtil_Worktree_Call {
	return &MockGitUtil_Worktree_Call{Call: _e.mock.On("Worktree", repo)}
}

func (_c *MockGitUtil_Worktree_Call) Run(run func(repo *git.Repository)) *MockGitUtil_Worktree_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*git.Repository))
	})
	return _c
}

func (_c *MockGitUtil_Worktree_Call) Return(_a0 *git.Worktree, _a1 error) *MockGitUtil_Worktree_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGitUtil_Worktree_Call) RunAndReturn(run func(*git.Repository) (*git.Worktree, error)) *MockGitUtil_Worktree_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockGitUtil creates a new instance of MockGitUtil. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockGitUtil(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockGitUtil {
	mock := &MockGitUtil{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
